//--------- Описание функций ---------

#include "stdafx.h"
#include "Heap.h"
#include <iostream>
#include <iomanip>

// Вывод данных кучи(ключа)
void AAA::print()
{
	std::cout << x;
}

int AAA::getPriority() const // Получить приоритет элемента кучи
{
	return x; // В нашем случае приоритет равен значению ключа
}



namespace heap // После данное пространство имён придётся прописывать
{
	//---------- Создание кучи ----------
	Heap create(int maxsize, CMP(*f)(void*, void*))
	{
		return *(new Heap(maxsize, f)); // Выделяем память для кучи
	}

	// Элемент левого поддерева
	int Heap::left(int ix)
	{
		return (2 * ix + 1 >= size) ? -1 : (2 * ix + 1);
		// Возвращаем ИНДЕКС ЭЛЕМЕНТА

		// В данном случае (2 * ix + 1 >= size) - УСЛОВИЕ
		// -1 - ВЫРАЖЕНИЕ 1
		// (2 * ix + 1) - ВЫРАЖЕНИЕ 2
	}

	// Элемент правого поддерева
	int Heap::right(int ix)
	{
		return (2 * ix + 2 >= size) ? -1 : (2 * ix + 2);
		// Возвращаем ИНДЕКС ЭЛЕМЕНТА
	}

	// Родительский элемент
	int Heap::parent(int ix)
	{
		return ( (ix + 1) / 2 ) - 1;
	}

	// Перетасовка элементов
	void Heap::swap(int i, int j)
	{
		void* buf = storage[i];
		storage[i] = storage[j];
		storage[j] = buf;
		// Поменяли местами i-ый и j-ый элементы 
	}

	//-------- Сортировка кучи max -> min --------

	// У кучи должно соблюдаться свойсвто:
	// Родитель должен быть больше своих потомков
	// Если это свойство не соблюдается, то мы перебрасываем наибольшего потомка на место родителя
	void Heap::heapify(int ix) // аргументом у нас является индекс элемента
	{
		int l = left(ix); // Индекс левого потомка
		int r = right(ix); // Индекс правого потомка
		int irl = ix; // Индекс родителя
		if (l > 0)
		{
				if (isGreat(storage[l], storage[ix])) // Если левый потомок больше родителя (ЗНАЧЕНИЕ)
				{
					irl = l; // То он становится родителем
				}

				if (r > 0 && isGreat(storage[r], storage[irl])) // Если правый потомок больше родителя (ЗНАЧЕНИЕ)
				{
					irl = r; // То он становится родителем
				}

				if (irl != ix) // Если индекс родителя не равен его текущему индексу
				{
					swap(ix, irl); // Меняем их местами
					heapify(irl); // и упорядочиваем нашу кучу относительно нового родителя
				}
		}
	}


	//--------- Вставка нового элемента ---------
	void Heap::insert(void* x)
	{
		int i;
		if (!isFull()) // Если дерево не заполнено
		{
			// Индексу присваиваем значение ++size - 1
			// По умолчанию size = 0
			storage[i = ++size - 1] = x; // И записываем в массив введённое значение
			while ( i > 0 && isLess(storage[parent(i)], storage[i]) ) // Если индекс > 0 и значение
				// хранящееся под индексом значение родителя меньше значения под текущим индексом 
			{
				swap(parent(i), i); // То меняем их значения местами
				i = parent(i); // И индексы тоже
			}
		}
	}

	//--------- Удаление максимального элемента ---------
	void* Heap::extractMax()
	{
		void* rc = nullptr; // Создаём нулевой указатель
		if (!isEmpty())
		{
			rc = storage[0]; // Указатель будет указывать на корень, так как он является
			// самым большим элементом по умолчанию
			storage[0] = storage[size - 1]; // Смещаем другие элементы на место корня
			size--; // попутно уменьшая размер дерева
			heapify(0); // И производим упорядочивание кучи относительно корня
		} return rc;
	}



	void Heap::scan(int i) const  // Вывод значений элементов на экран
	{
		int probel = 20;
		std::cout << '\n';
		if (size == 0)
			std::cout << "Куча пуста";
		for (int u = 0, y = 0; u < size; u++)
		{
			std::cout << std::setw(probel + 10) << std::setfill(' ');
			((AAA*)storage[u])->print();
			if (u == y)
			{
				std::cout << '\n';
				if (y == 0)
					y = 2;
				else
					y += y * 2;
			}
			probel /= 2;
		}
		std::cout << '\n';
	}

	//--------- Новые функции ---------

	//--------- Удаление корня ( вершины) ---------
	void* Heap::extractHead()
	{
		void* rc = nullptr; // Создаём нулевой указатель
		if (!isEmpty())
		{
			rc = storage[0]; // Указатель будет указывать на корень, так как он является
			// самым большим элементом по умолчанию
			storage[0] = storage[size - 1]; // Смещаем другие элементы на место корня
			size--; // попутно уменьшая размер дерева
			heapify(0); // И производим упорядочивание кучи относительно корня
		} return rc;
	}
	//--------- Поиск минимального элемента ---------
	int Heap::findMin()
	{
		int min = 0;
		void *rc = nullptr; // Используется для поиска минимального элемента
		rc = storage[0]; // Пока что указываем на корень
		AAA *for_print = (AAA*)storage[0]; // Используется для вывода значения элемента
		for (int i = 0; i < size; i++)
		{
			if (storage[i] < storage[min]) // Если текущий элемент меньше сравниваемого
			{
				rc = storage[i]; // То присваиваем ему значение меньшего элемента
				for_print = (AAA*)storage[i]; // То же самое делаем для "выводной переменной"
				min = i; // И не забываем про индекс минимального элемента
			}
		}
		std::cout << "Минимальный элемент кучи - "; for_print->print(); std::cout << std::endl; // Выводим минимальный элемент
		return min; // Возвращаем его индекс
	}

	//------------ Смена индексами с родителем ------------
	void Heap::swapParent(int ix)
	{
		int l = left(ix), r = right(ix), p = parent(ix);
		if (p >= 0)
		{
			swap(p, ix);
			swapParent(p);
		}
	}

	//--------- Удаление i-го элемента ---------
	void* Heap::extractI(int ix)
	{
		swapParent(ix);
		return extractMax();
	}

	//---------- Удаление минимального элемента ----------
	void* Heap::extractMin()
	{
		int min = findMin();
		return extractI(min);
	}

	//---------- Удаление кучи ----------
	void Heap::deleteHeap()
	{
		if (!isEmpty()) // Если куча не пустая
		{
			size = 0; // Даём ей нулевой размер(удаляем)
			this->~Heap(); // ~ - Деструктор (используем, когда что-то удаляем)
		}
	}

}



